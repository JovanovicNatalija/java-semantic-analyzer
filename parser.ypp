%{
    #include <iostream>
    #include <string>
    #include <cstdlib>
    #include <vector>
    #include "type.hpp"
    #include "ast.hpp"
    #include <map>

    using namespace std;

    #define YYDEBUG 1

    void yyerror(string s) {
        cerr << s << endl;
        exit(EXIT_FAILURE);
    }

    int yylex();

    map<string, Type*> tablica;
    
<<<<<<< HEAD
=======
    /* obrati paznju na ovu tablicu, nije ista kao ono sto si ti radila */
>>>>>>> c21f709d39009fe0eb9ae919c240a1d90e9aca4f
    map<string, Class*> tablicaKlasa;

    Type* tip(string t) {
        if(t == "int") 
            return new IntType();
        else if(t == "double")
            return new DoubleType();
        else if(t == "char")
            return new CharType();
        
        return new StringType();  
    }
%}

%union {
    int i;
    ExprAST* e;
    string *s;
    vector < string >* v;
    vector < Field* >* v1;
    vector < pair < Type*, string > >* v2;  
    pair < Type*, string >* p;
    vector < Method* >* v4;
    Constructor* c;
    Method* m;
    Class* c1;
    vector < Class* >* v5; 
}

%token new_token char_token public_token static_token void_token main_token string_token double_token Main_token
%token private_token class_token return_token
%token <s> id_token tip_token klasni_tip_token

%token <i> int_token

%type <e> E Naredba NizNaredbi 
%type <m> Metod

%type <v> Polja
%type <v1> Polje NizPolja
%type <v2> NizArgumenata
%type <p> Argument
%type <v4> NizMetoda
%type <c> Konstruktor
%type <c1> Klasa
%type <v5> NizKlasa

%left '+' '-'
%left '*' '/' 

%% 
Program : NizKlasa KlasaMain {

}
;

NizKlasa : NizKlasa Klasa {
    $$ = $1;
    $$->push_back($2);
}
| Klasa {
    $$ = new vector < Class* >();
    $$->push_back($1);
}
;

<<<<<<< HEAD
Klasa : class_token klasni_tip_token '{' NizPolja Konstruktor NizMetoda '}' {
=======
Klasa : class_token id_token '{' NizPolja Konstruktor NizMetoda '}' {
>>>>>>> c21f709d39009fe0eb9ae919c240a1d90e9aca4f
    map<string, Class*>::iterator tmp = tablicaKlasa.find(*$2);
    if(tmp != tablicaKlasa.end()) {
        cerr << "Class " << *$2 << " is already defined." << endl;
        exit(EXIT_FAILURE); 
    }

    if(*$2 != $5->getName()) {
        cerr << "Name of constructor and name of class must be equal! " << endl;
        exit(EXIT_FAILURE);
    }
<<<<<<< HEAD
    
    $$ = new Class(*$2, *$4, $5, *$6);
=======

    cout << "ovde ulazi" << endl;
    
    $$ = new Class(*$2, *$4, *$5, *$6);
    
    cout << "ovde ne ulazi " << endl;

    // vrv je greska negde u konstruktoru
>>>>>>> c21f709d39009fe0eb9ae919c240a1d90e9aca4f

    tablicaKlasa[*$2] = $$;
    delete $2;
    delete $4;
<<<<<<< HEAD
=======
    delete $5;
>>>>>>> c21f709d39009fe0eb9ae919c240a1d90e9aca4f
    delete $6;
}
;

KlasaMain : public_token class_token Main_token '{' public_token static_token void_token main_token '(' tip_token '[' ']' id_token ')' '{' NizNaredbi '}' '}' {
    Type* lastCheck = $16->typecheck();
    if(lastCheck) {
        cout << "There are no semantics errors." << endl;
    }
    delete lastCheck;
}
;

// polja su uradjena 
NizPolja : NizPolja Polje {
    $$ = $1;
    for(Field* f: *($2))
        $$->push_back(f);
    delete $2;
}
| Polje {
    $$ = $1;
}
;

Polje : public_token tip_token Polja {
    $$ = new vector<Field*>();
    for(string s: *($3))
        $$->push_back(new Field(tip(*$2), s));
    delete $2;
    delete $3;
} 

Polja : Polja ',' id_token ';' {
    $$ = $1;
    $$->push_back(*$3);
    delete $3;
}
| id_token ';' {
    $$ = new vector<string>();
    $$->push_back(*$1);
    delete $1;
}
;

// konstruktor je uradjen
<<<<<<< HEAD
Konstruktor :  public_token klasni_tip_token '(' NizArgumenata ')' '{' NizNaredbi '}' {
=======
Konstruktor :  public_token id_token '(' NizArgumenata ')' '{' NizNaredbi '}' {
>>>>>>> c21f709d39009fe0eb9ae919c240a1d90e9aca4f
    $$ = new Constructor(*$2, *$4, $7);
    delete $2;
    delete $4;
}
;

NizArgumenata : NizArgumenata ',' Argument {
    $$ = $1;
    $$->push_back(*$3);
    delete $1;
}
| Argument {
    $$ = new vector < pair < Type*, string > >();
    $$->push_back(*$1);
    delete $1;
}
| {
    $$ = new vector < pair < Type*, string > >();
}
;

Argument : tip_token id_token {
    $$ = new pair < Type*, string >(tip(*$1), *$2);
}
| tip_token '[' ']' id_token {
    $$ = new pair < Type*, string > (new ArrayType(0, tip(*$1)), *$4);
}
;

// niz metoda uradjen
NizMetoda : NizMetoda Metod {
    $$ = $1;
    $$->push_back($2);
}
| Metod {
<<<<<<< HEAD
    $$ = new vector<Method*>;
=======
>>>>>>> c21f709d39009fe0eb9ae919c240a1d90e9aca4f
    $$->push_back($1);
}
;

// NizArgumenata sam stavila da moze da ide u prazno i onda ovde ne treba poseban slucaj kada u zagradama nemamo nista
// Naredba moze da ode u prazno i tu pravim EmptyAST(ne znam da li postoji bolje resenje) i onda ne treba poseban slucaj i za to

Metod : public_token tip_token id_token '(' NizArgumenata ')' '{' NizNaredbi return_token E ';' '}' {
    Type* methodType = tip(*$2);
    $$ = new Method(methodType, *$3, *$5, $8, $10);
    delete $3;
    delete $5;
}
;


NizNaredbi : NizNaredbi Naredba ';' {
    $$ = new SeqExprAST($1, $2);
}
| Naredba ';' {
    $$ = $1;
}
| {
    $$ = new EmptyAST();
}
;

Naredba : tip_token id_token '=' E  {
    map<string, Type*>::iterator tmp = tablica.find(*$2);
    if(tmp != tablica.end()) {
        cerr << "Variable " << *$2 << " is already defined" << endl;
        exit(EXIT_FAILURE);
    }
    if(*$1 == "int") {
        $$ = new AssignExprAST(*$2, $4, new IntType());
        tablica[*$2] = new IntType();
    } else if(*$1 == "double") {
        $$ = new AssignExprAST(*$2, $4, new DoubleType());
        tablica[*$2] = new DoubleType();
    } else if(*$1 == "char") {
        $$ = new AssignExprAST(*$2, $4, new CharType());
        tablica[*$2] = new CharType();
    } else {
        $$ = new AssignExprAST(*$2, $4, new StringType());
        tablica[*$2] = new StringType();
    }

    delete $1;
    delete $2;
}
| tip_token '['']' id_token '=' new_token tip_token '[' int_token ']' {
    map<string, Type*>::iterator tmp = tablica.find(*$4);
    if(tmp != tablica.end()) {
        cerr << "Variable " << *$4 << " is already defined" << endl;
        exit(EXIT_FAILURE);
    }

    Type* varArrayType = NULL;
    if(*$1 == "int") {
        varArrayType = new IntType();
    } else if(*$1 == "double") {
        varArrayType = new DoubleType();
    } else if(*$1 == "char") {
        varArrayType = new CharType();
    } else {
        varArrayType = new StringType();
    }

    Type* exprArrayType = NULL;
    if(*$7 == "int") {
        exprArrayType = new IntType();
    } else if(*$7 == "double") {
        exprArrayType = new DoubleType();
    } else if(*$7 == "char") {
        exprArrayType = new CharType();
    } else {
        exprArrayType = new StringType();
    }

    tablica[*$4] = new ArrayType($9, varArrayType->copy());

    $$ = new AssignExprAST(*$4, new ConstantExprAST(new ArrayType($9, exprArrayType)), new ArrayType($9, varArrayType));

    delete $1;
    delete $4;
    delete $7;
}
| tip_token id_token {
    map<string, Type*>::iterator tmp = tablica.find(*$2);
    if(tmp != tablica.end()) {
        cerr << "Variable " << *$2 << " is already defined" << endl;
        exit(EXIT_FAILURE);
    }
    if(*$1 == "int") {
        $$ = new AssignExprAST(*$2, new ConstantExprAST(new IntType()), new IntType());
        tablica[*$2] = new IntType();
    } else if(*$1 == "double") {
        $$ = new AssignExprAST(*$2, new ConstantExprAST(new DoubleType()), new DoubleType());
        tablica[*$2] = new DoubleType();
    } else if(*$1 == "char") {
        $$ = new AssignExprAST(*$2, new ConstantExprAST(new CharType()), new CharType());
        tablica[*$2] = new CharType();
    } else {
        $$ = new AssignExprAST(*$2, new ConstantExprAST(new StringType()), new StringType());
        tablica[*$2] = new StringType();
    }

    delete $1;
    delete $2;
}
| id_token '=' E {
    $$ = new PredefineExprAST(*$1, $3);
    delete $1;
}
| id_token '[' E ']' '=' E {
    $$ = new PredefineArrayExprAST(*$1, $3, $6);
    delete $1;
}
| klasni_tip_token id_token '=' E {
    map<string, Class*>::iterator tmp = tablicaKlasa.find(*$1);
    if(tmp == tablicaKlasa.end()) {
        cerr << "Class " << *$1 << " is not defined." << endl;
        exit(EXIT_FAILURE); 
    }

    map<string, Type*>::iterator t = tablica.find(*$2);
    if(t != tablica.end()) {
        cerr << "Variable " << *$2 << " is already defined" << endl;
        exit(EXIT_FAILURE);
    }

    tablica[*$2] = new ClassType(*$1);
    $$ = new AssignExprAST(*$2, $4, new ClassType(*$1));
    delete $2;
    delete $1;
}
| klasni_tip_token id_token {
    map<string, Class*>::iterator tmp = tablicaKlasa.find(*$1);
    if(tmp == tablicaKlasa.end()) {
        cerr << "Class " << *$1 << " is not defined." << endl;
        exit(EXIT_FAILURE); 
    }

    map<string, Type*>::iterator t = tablica.find(*$2);
    if(t != tablica.end()) {
        cerr << "Variable " << *$2 << " is already defined" << endl;
        exit(EXIT_FAILURE);
    }

    tablica[*$2] = new ClassType(*$1);
    $$ = new AssignExprAST(*$2, new ConstantExprAST(new ClassType(*$1)), new ClassType(*$1));
    delete $2;
    delete $1;
}
;

E : E '+' E {
    $$ = new AddExprAST($1, $3);
}
| E '-' E {
    $$ = new SubExprAST($1, $3);
}
| E '*' E {
    $$ = new MulExprAST($1, $3);
}
| E '/' E  {
    $$ = new DivExprAST($1, $3);
}
| '(' E ')' {
    $$ = $2;
}
| id_token {
    $$ = new VariableExprAST(*$1);
    delete $1;
}
| string_token {
    $$ = new ConstantExprAST(new StringType());
}
| double_token {
    $$ = new ConstantExprAST(new DoubleType());
}
| int_token {
    $$ = new ConstantExprAST(new IntType());
}
| char_token {
    $$ = new ConstantExprAST(new CharType());
}
| id_token '[' E ']' {
    $$ = new ElementOfArrayExprAST(*$1, $3);
    delete $1;
}
| new_token klasni_tip_token '(' ')' {
    $$ = new ConstantExprAST(new ClassType(*$2));
    delete $2;
}
;

%%

int main() {
    //yydebug = 1;

    yyparse();

    return 1;
}
  